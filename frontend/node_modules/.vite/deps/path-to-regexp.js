import {
  __commonJS
} from "./chunk-ZS7NZCD4.js";

// node_modules/path-to-regexp/dist/index.js
var require_dist = __commonJS({
  "node_modules/path-to-regexp/dist/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pathToRegexp = exports.match = exports.compile = exports.parse = exports.TokenData = void 0;
    var DEFAULT_DELIMITER = "/";
    var NOOP_VALUE = (value) => value;
    var ID_CHAR = new RegExp("^\\p{XID_Continue}$", "u");
    var SIMPLE_TOKENS = {
      "!": "!",
      "@": "@",
      ";": ";",
      ",": ",",
      "*": "*",
      "+": "+",
      "?": "?",
      "{": "{",
      "}": "}"
    };
    function lexer(str) {
      const chars = [...str];
      const tokens = [];
      let i = 0;
      while (i < chars.length) {
        const value = chars[i];
        const type = SIMPLE_TOKENS[value];
        if (type) {
          tokens.push({ type, index: i++, value });
          continue;
        }
        if (value === "\\") {
          tokens.push({ type: "ESCAPED", index: i++, value: chars[i++] });
          continue;
        }
        if (value === ":") {
          let name = "";
          while (ID_CHAR.test(chars[++i])) {
            name += chars[i];
          }
          if (!name) {
            throw new TypeError(`Missing parameter name at ${i}`);
          }
          tokens.push({ type: "NAME", index: i, value: name });
          continue;
        }
        if (value === "(") {
          const pos = i++;
          let count = 1;
          let pattern = "";
          if (chars[i] === "?") {
            throw new TypeError(`Pattern cannot start with "?" at ${i}`);
          }
          while (i < chars.length) {
            if (chars[i] === "\\") {
              pattern += chars[i++] + chars[i++];
              continue;
            }
            if (chars[i] === ")") {
              count--;
              if (count === 0) {
                i++;
                break;
              }
            } else if (chars[i] === "(") {
              count++;
              if (chars[i + 1] !== "?") {
                throw new TypeError(`Capturing groups are not allowed at ${i}`);
              }
            }
            pattern += chars[i++];
          }
          if (count)
            throw new TypeError(`Unbalanced pattern at ${pos}`);
          if (!pattern)
            throw new TypeError(`Missing pattern at ${pos}`);
          tokens.push({ type: "PATTERN", index: i, value: pattern });
          continue;
        }
        tokens.push({ type: "CHAR", index: i, value: chars[i++] });
      }
      tokens.push({ type: "END", index: i, value: "" });
      return new Iter(tokens);
    }
    var Iter = class {
      constructor(tokens) {
        this.tokens = tokens;
        this.index = 0;
      }
      peek() {
        return this.tokens[this.index];
      }
      tryConsume(type) {
        const token = this.peek();
        if (token.type !== type)
          return;
        this.index++;
        return token.value;
      }
      consume(type) {
        const value = this.tryConsume(type);
        if (value !== void 0)
          return value;
        const { type: nextType, index } = this.peek();
        throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}: https://git.new/pathToRegexpError`);
      }
      text() {
        let result = "";
        let value;
        while (value = this.tryConsume("CHAR") || this.tryConsume("ESCAPED")) {
          result += value;
        }
        return result;
      }
      modifier() {
        return this.tryConsume("?") || this.tryConsume("*") || this.tryConsume("+") || "";
      }
    };
    var TokenData = class {
      constructor(tokens, delimiter) {
        this.tokens = tokens;
        this.delimiter = delimiter;
      }
    };
    exports.TokenData = TokenData;
    function parse(str, options = {}) {
      const { delimiter = DEFAULT_DELIMITER, encodePath = NOOP_VALUE } = options;
      const tokens = [];
      const it = lexer(str);
      let key = 0;
      do {
        const path = it.text();
        if (path)
          tokens.push(encodePath(path));
        const name = it.tryConsume("NAME");
        const pattern = it.tryConsume("PATTERN");
        if (name || pattern) {
          tokens.push({
            name: name || String(key++),
            pattern
          });
          const next = it.peek();
          if (next.type === "*") {
            throw new TypeError(`Unexpected * at ${next.index}, you probably want \`/*\` or \`{/:foo}*\`: https://git.new/pathToRegexpError`);
          }
          continue;
        }
        const asterisk = it.tryConsume("*");
        if (asterisk) {
          tokens.push({
            name: String(key++),
            pattern: `[^${escape(delimiter)}]*`,
            modifier: "*",
            separator: delimiter
          });
          continue;
        }
        const open = it.tryConsume("{");
        if (open) {
          const prefix = it.text();
          const name2 = it.tryConsume("NAME");
          const pattern2 = it.tryConsume("PATTERN");
          const suffix = it.text();
          const separator = it.tryConsume(";") ? it.text() : prefix + suffix;
          it.consume("}");
          const modifier = it.modifier();
          tokens.push({
            name: name2 || (pattern2 ? String(key++) : ""),
            prefix: encodePath(prefix),
            suffix: encodePath(suffix),
            pattern: pattern2,
            modifier,
            separator
          });
          continue;
        }
        it.consume("END");
        break;
      } while (true);
      return new TokenData(tokens, delimiter);
    }
    exports.parse = parse;
    function compile(path, options = {}) {
      const data = path instanceof TokenData ? path : parse(path, options);
      return compileTokens(data, options);
    }
    exports.compile = compile;
    function tokenToFunction(token, encode) {
      if (typeof token === "string") {
        return () => token;
      }
      const encodeValue = encode || NOOP_VALUE;
      const repeated = token.modifier === "+" || token.modifier === "*";
      const optional = token.modifier === "?" || token.modifier === "*";
      const { prefix = "", suffix = "", separator = "" } = token;
      if (encode && repeated) {
        const stringify2 = (value, index) => {
          if (typeof value !== "string") {
            throw new TypeError(`Expected "${token.name}/${index}" to be a string`);
          }
          return encodeValue(value);
        };
        const compile2 = (value) => {
          if (!Array.isArray(value)) {
            throw new TypeError(`Expected "${token.name}" to be an array`);
          }
          if (value.length === 0)
            return "";
          return prefix + value.map(stringify2).join(separator) + suffix;
        };
        if (optional) {
          return (data) => {
            const value = data[token.name];
            if (value == null)
              return "";
            return value.length ? compile2(value) : "";
          };
        }
        return (data) => {
          const value = data[token.name];
          return compile2(value);
        };
      }
      const stringify = (value) => {
        if (typeof value !== "string") {
          throw new TypeError(`Expected "${token.name}" to be a string`);
        }
        return prefix + encodeValue(value) + suffix;
      };
      if (optional) {
        return (data) => {
          const value = data[token.name];
          if (value == null)
            return "";
          return stringify(value);
        };
      }
      return (data) => {
        const value = data[token.name];
        return stringify(value);
      };
    }
    function compileTokens(data, options) {
      const { encode = encodeURIComponent, loose = true, validate = true } = options;
      const reFlags = flags(options);
      const stringify = toStringify(loose, data.delimiter);
      const keyToRegexp = toKeyRegexp(stringify, data.delimiter);
      const encoders = data.tokens.map((token) => {
        const fn = tokenToFunction(token, encode);
        if (!validate || typeof token === "string")
          return fn;
        const pattern = keyToRegexp(token);
        const validRe = new RegExp(`^${pattern}$`, reFlags);
        return (data2) => {
          const value = fn(data2);
          if (!validRe.test(value)) {
            throw new TypeError(`Invalid value for "${token.name}": ${JSON.stringify(value)}`);
          }
          return value;
        };
      });
      return function path(data2 = {}) {
        let path2 = "";
        for (const encoder of encoders)
          path2 += encoder(data2);
        return path2;
      };
    }
    function match(path, options = {}) {
      const { decode = decodeURIComponent, loose = true } = options;
      const data = path instanceof TokenData ? path : parse(path, options);
      const stringify = toStringify(loose, data.delimiter);
      const keys = [];
      const re = tokensToRegexp(data, keys, options);
      const decoders = keys.map((key) => {
        if (decode && (key.modifier === "+" || key.modifier === "*")) {
          const re2 = new RegExp(stringify(key.separator || ""), "g");
          return (value) => value.split(re2).map(decode);
        }
        return decode || NOOP_VALUE;
      });
      return function match2(pathname) {
        const m = re.exec(pathname);
        if (!m)
          return false;
        const { 0: path2, index } = m;
        const params = /* @__PURE__ */ Object.create(null);
        for (let i = 1; i < m.length; i++) {
          if (m[i] === void 0)
            continue;
          const key = keys[i - 1];
          const decoder = decoders[i - 1];
          params[key.name] = decoder(m[i]);
        }
        return { path: path2, index, params };
      };
    }
    exports.match = match;
    function escape(str) {
      return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
    }
    function looseReplacer(value, loose) {
      return loose ? `${escape(value)}+` : escape(value);
    }
    function toStringify(loose, delimiter) {
      if (!loose)
        return escape;
      const re = new RegExp(`[^${escape(delimiter)}]+|(.)`, "g");
      return (value) => value.replace(re, looseReplacer);
    }
    function flags(options) {
      return options.sensitive ? "" : "i";
    }
    function tokensToRegexp(data, keys, options) {
      const { trailing = true, start = true, end = true, loose = true } = options;
      const stringify = toStringify(loose, data.delimiter);
      const keyToRegexp = toKeyRegexp(stringify, data.delimiter);
      let pattern = start ? "^" : "";
      for (const token of data.tokens) {
        if (typeof token === "string") {
          pattern += stringify(token);
        } else {
          if (token.name)
            keys.push(token);
          pattern += keyToRegexp(token);
        }
      }
      if (trailing)
        pattern += `(?:${stringify(data.delimiter)})?`;
      pattern += end ? "$" : `(?=${escape(data.delimiter)}|$)`;
      return new RegExp(pattern, flags(options));
    }
    function toKeyRegexp(stringify, delimiter) {
      const segmentPattern = `[^${escape(delimiter)}]+?`;
      return (key) => {
        const prefix = key.prefix ? stringify(key.prefix) : "";
        const suffix = key.suffix ? stringify(key.suffix) : "";
        const modifier = key.modifier || "";
        if (key.name) {
          const pattern = key.pattern || segmentPattern;
          if (key.modifier === "+" || key.modifier === "*") {
            const mod = key.modifier === "*" ? "?" : "";
            const split = key.separator ? stringify(key.separator) : "";
            return `(?:${prefix}((?:${pattern})(?:${split}(?:${pattern}))*)${suffix})${mod}`;
          }
          return `(?:${prefix}(${pattern})${suffix})${modifier}`;
        }
        return `(?:${prefix}${suffix})${modifier}`;
      };
    }
    function pathToRegexp(path, options = {}) {
      const data = path instanceof TokenData ? path : parse(path, options);
      const keys = [];
      const regexp = tokensToRegexp(data, keys, options);
      return Object.assign(regexp, { keys });
    }
    exports.pathToRegexp = pathToRegexp;
  }
});
export default require_dist();
//# sourceMappingURL=path-to-regexp.js.map
